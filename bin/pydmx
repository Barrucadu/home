#!/usr/bin/env python3

# Python script to control dmx devices. Requires the server to be up and running.

import os, sys, imp, subprocess, curses, curses.ascii, curses.wrapper

# ----- Global Variables ----- #
datapath   = None
data       = None
activename = None
chandata   = None

# ----- Function Definitions ----- #
def dmxcmd(channel, value=None, name=None):
    global activename
    global chandata

    if name == None:
        name = activename

    argvector = []
    if value == None:
        argvector = ["k8062", str(channel)]
    else:
        chandata[name][channel][0] = int(value)
        channel += chandata[name]['info']['startchan']
        argvector = ["k8062", str(channel), str(value)]
        
    process = subprocess.Popen(argvector, stdout=subprocess.PIPE)
    output  = process.communicate()
    
    if value == None: return int(output[0])

def loaddmx(name):
    global chandata

    loaded = False
    for chan in chandata[name].keys():
        if not chan == 'info':
            newval = dmxcmd(chan + chandata[name]['info']['startchan'])
            if not chandata[name][chan][0] == newval:
                chandata[name][chan][0] = newval
                loaded = True

    return loaded

def nameinit(newname, newmodel, newstartchan):
    global chandata
    global data

    datafile = datapath + "/pydmx/" + newmodel + ".py"
    
    try:
        data = imp.load_source(newmodel, datafile)
    except IOError:
        print("The datafile " + datapath + " does not exist.")

    chandata.update({newname : {'info' : {'model'     : newmodel,
                                          'startchan' : int(newstartchan)}}})
    for i in data.dmx.keys():
        for j in data.dmx[i].keys():
            key = data.dmx[i][j][1]
            var = [data.dmx[i][j][0], data.dmx[i][j][2]]
            
            if len(data.dmx[i][j]) > 3:
                var.append(data.dmx[i][j][3])
        
            if key in chandata[newname].keys():
                chandata[newname][key].append(var)
            else:
                chandata[newname].update({key : [0, var]})

    dontload = loaddmx(newname)

    if not dontload:
        for channel in range(0, len(data.defaults)):
            dmxcmd(channel, data.defaults[channel], newname)
             

def updateui(stdscr, active):
    global chandata
    global activename
    global data

    channels = chandata[activename]

    stdscr.erase()

    numbars       = len(channels) - 1
    height, width = stdscr.getmaxyx()
    barsize       = int((width - 12) / numbars)
    barheight     = height - 15
    barwidth      = 2

    for i in range(0, numbars):
        channel = channels[i]
        value = channel[0]
        
        stdscr.move(5, i * barsize + 6)
        
        attr = curses.color_pair(0)
        if i == active:
            attr = curses.color_pair(4)
            
        stdscr.addstr(data.channels[i], attr)

        stdscr.move(6, i * barsize + 6)
        stdscr.addstr(str(value))

        stdscr.move(8, i * barsize + 6)
        stdscr.addch(curses.ACS_ULCORNER)
        
        for j in range(0, barwidth):
            stdscr.addch(curses.ACS_HLINE)
            
        stdscr.addch(curses.ACS_URCORNER)

        goesupto = 0
        if not value == 0:
            goesupto = int(barheight * value / 255)
        
        for j in range(1, barheight):
            stdscr.move(j + 8, i * barsize + 6)
            stdscr.addch(curses.ACS_VLINE)

            y = barheight - j
            
            for k in range(0, barwidth):
                attr = curses.color_pair(0)
                
                if y <= goesupto:
                    if y >= 2 * barheight / 3:
                        attr = curses.color_pair(1)
                    elif y >= barheight / 3:
                        attr = curses.color_pair(2)
                    else:
                        attr = curses.color_pair(3)
                    
                stdscr.addch(" ", attr)
                
            stdscr.addch(curses.ACS_VLINE)

        stdscr.move(8 + barheight, i * barsize + 6)
        stdscr.addch(curses.ACS_LLCORNER)
        
        for j in range(0, barwidth):
            stdscr.addch(curses.ACS_HLINE)
            
        stdscr.addch(curses.ACS_LRCORNER)
        
        stdscr.move(10 + barheight, i * barsize + 6)
        stdscr.addstr(str(i + chandata[activename]['info']['startchan']))

        if active == i:
            for chan in channel:
                if type(chan) is list:
                    if chan[0] == value or (len(chan) > 2 and (chan[0] <= value <= chan[2])):

                        stdscr.move(height - 3, 1)
                        stdscr.addstr("Name:   ", curses.color_pair(5) and curses.A_BOLD)
                        stdscr.addstr(activename)

                        stdscr.move(height - 2, 1)
                        stdscr.addstr("Device: ", curses.color_pair(5) and curses.A_BOLD)
                        stdscr.addstr(data.name)
                        
                        stdscr.move(height - 1, 1)
                        stdscr.addstr("State:  ", curses.color_pair(5) and curses.A_BOLD)
                        stdscr.addstr(chan[1])
        

def cursesui(stdscr):
    global chandata
    global activename
    
    curses.curs_set(0)

    activechan = 0

    curses.init_pair(1, curses.COLOR_RED,   curses.COLOR_RED)
    curses.init_pair(2, curses.COLOR_BLUE,  curses.COLOR_BLUE)
    curses.init_pair(3, curses.COLOR_GREEN, curses.COLOR_GREEN)
    curses.init_pair(4, curses.COLOR_RED,   curses.COLOR_BLACK)
    curses.init_pair(5, curses.COLOR_CYAN,  curses.COLOR_BLACK)

    while True:
        updateui(stdscr, activechan)
        
        ch     = stdscr.getch()
        newval = -1
        
        if ch == ord('q'):
            break
        
        elif ch == ord('r'):
            loaddmx(activename)

        elif ch == curses.KEY_LEFT:
            if not activechan == 0:
                activechan -= 1
                
        elif ch == curses.KEY_RIGHT:
            if not activechan == len(chandata[activename]) - 1:
                activechan += 1
                
        elif ch in [curses.KEY_UP, curses.KEY_PPAGE, ord('n')]:
            for cmd in chandata[activename][activechan]:
                if type(cmd) is list:
                    newdata = chandata[activename][activechan][0] + 1
                    if ch == curses.KEY_PPAGE:
                        newdata += 9

                    if len(cmd) > 2 and (cmd[0] <= newdata <= cmd[2]) and not ch == ord('n'):
                        newval = newdata
                    elif cmd[0] > chandata[activename][activechan][0]:
                        if cmd[0] < newval or newval == -1:
                            newval = cmd[0]
                            
        elif ch in [curses.KEY_DOWN, curses.KEY_NPAGE, ord('p')]:
            for cmd in chandata[activename][activechan]:
                if type(cmd) is list:
                    newdata = chandata[activename][activechan][0] - 1
                    if ch == curses.KEY_NPAGE:
                        newdata -= 9

                    if len(cmd) > 2 and (cmd[0] <= newdata <= cmd[2]) and not ch == ord('p'):
                        newval = newdata
                    elif cmd[0] < chandata[activename][activechan][0]:
                        if cmd[0] > newval or newval == -1:
                            newval = cmd[0]
                            
        elif ch == ord('t'):
            newval = chandata[activename][activechan][0]
            for cmd in chandata[activename][activechan]:
                if type(cmd) is list:
                    if len(cmd) > 2 and newval < cmd[2]:
                        newval = cmd[2]
                    elif newval < cmd[0]:
                        newval = cmd[0]
            
        elif ch == ord('b'):
            newval = chandata[activename][activechan][0]
            for cmd in chandata[activename][activechan]:
                if type(cmd) is list:
                    if newval > cmd[0]:
                        newval = cmd[0]            
            
        if not newval == -1:
            dmxcmd(activechan, newval)
    
    curses.curs_set(1)

def listcmds(arg):
    global data
    
    print("Commands for " + data.name + ":")
    for i in data.dmx.keys():
        if arg == "" or arg == i:
            commands = []
            longest  = 0
            
            for j in data.dmx[i].keys():
                cmd = "'" + j + "'"
                if data.dmx[i][j][0] == "?":
                    cmd = "'" + j + " [val]'"
                    
                commands.append([cmd, data.dmx[i][j][2]])
                
                if len(cmd) > longest:
                    longest = len(cmd)

            print(i)
            for cmd in commands:
                spacing = longest - len(cmd[0])
                print("    " + cmd[0], cmd[1].rjust(len(cmd[1]) + spacing))
            print()
            
def parsecmd(command, arg, arg2, arg3):
    global data
    global chandata
    global activename
    
    funbreak = False

    if command == "list":
        listcmds(arg)
    elif command == "curses":
        curses.wrapper(cursesui)
    elif command == "names":
        for name in chandata.keys():
            if name == activename:
                print(name, "[active]")
            else:
                print(name)
                
            print("    Model:", chandata[name]['info']['model'])
            print("    Start:", chandata[name]['info']['startchan'])
            
    elif command == "new":
        if arg == "" or arg2 == "" or arg3 == "":
            print("Usage: new [name] [model] [startchannel]")
        else:
            nameinit(arg, arg2, arg3)

    elif command == "change":
        if arg in chandata.keys():
            activename = arg
        
    elif command == "reload":
        loaddmx(activename)
        
    else:
        try:
            cmd = data.dmx[command][arg]
        except KeyError:
            print("Command not found")
            funbreak = True
            
        if not funbreak:
            if type(cmd[0]) is int:
                # Normal set-channel-to-value command
                dmxcmd(cmd[1], cmd[0])
            else:
                # Set-channel-to-user value command
                dmxcmd(cmd[1], arg2)

def parsepromptline(line):
    bar      = line.split()
    command  = ""
    arg      = ""
    arg2     = ""
    arg3     = ""
    funbreak = False

    try:
        command = bar[0]
        
        if len(bar) > 1:
            arg = bar[1]
            
        if len(bar) > 2:
            arg2 = bar[2]

        if len(bar) > 3:
            arg3 = bar[3]
    except IndexError:
        funbreak = True

    return command, arg, arg2, arg3, funbreak


def enterprompt(command=None, arg=None, arg2=None):
    if command == None:
        
        funbreak = False
        foo = input("> ")
        
        if foo == "exit": 
            print("Exiting...")
            sys.exit(0)
        else:
            command, arg, arg2, arg3, funbreak = parsepromptline(foo)
            if not funbreak:
                parsecmd(command, arg, arg2, arg3)
                
    elif command == "exit":
        return False

    elif not command == "":
        parsecmd(command, arg, arg2)
    
    return True

# ----- System Setup----- #
model      = None
startchan  = None
command    = None
arg1       = None
arg2       = None
datapath   = None

try:
    model     = sys.argv[1]
    startchan = int(sys.argv[2])

    if len(sys.argv) > 3:
        command = sys.argv[3]
        
    if len(sys.argv) > 4:
        arg1 = sys.argv[4]

    if len(sys.argv) > 5:
        arg2 = sys.argv[5]
        
except IndexError:
    print("Usage: pydmx [model] [startchannel] (curses | list (command) | [command] [arg])")
    sys.exit(1)

datapath = os.getenv("XDG_DATA_HOME")
if datapath == "":
    datapath = os.getenv("HOME") + "/.local/share"

chandata = {}
nameinit('start', model, startchan)
activename = 'start'

#print(chandata)
#sys.exit()

# ----- Main ----- #
looping = True

while looping:
    looping = enterprompt(command, arg1, arg2)

print("Exiting...")
sys.exit(0)
