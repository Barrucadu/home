#!/usr/bin/env python3

# Python script to control dmx devices. Requires the server to be up and running.

import os, sys, imp, subprocess, curses, curses.ascii, curses.wrapper

# ----- Global Variables ----- #
datapath   = None
data       = None
dbodata    = {}
binddata   = {}
chandata   = {}
activename = ''
dmxcommands = {'get' : 'k8062 [channel]',
               'set' : 'k8062 [channel] [value]'}

# ----- Function Definitions ----- #
def printhelp():
    print("Usage: pydmx (help | [model] [startchannel])")
    print("The model and startchannel are optional, if not specified use the new command.")
    print("PyDMX also accepts commands from stdin, just make sure you end with an exit command to avoid an error message.\n")
    print("Internal commands:")
    print("    new [name] [model] [startchannel]  - initialise a new named device.")
    print("    names                              - list all devices.")
    print("    change [name]                      - change to a different named device.")
    print("    rename [old] [new]                 - change the name of a device. If the active device is renamed, a change command must immediately follow.")
    print("    bind [name] [chan] [name] [chan]   - always have the two channel values equal.")
    print("    unbind [name] [chan] [name] [chan] - undo a bind command.")
    print("    reload                             - reload cached DMX values for the current device from dmxd.")
    print("    curses                             - start the ncurses interface.")
    print("    list (arg)                         - list all commands for the current device provided by the data file. If arg is specified, restrict to that category.")
    print("    dbo                                - toggle dead black out.")
    print("    dmxgetcmd [command]                - set the DMX get command (default: k8062 [channel]).")
    print("    dmxsetcmd [command]                - set the DMX set command (default: k8062 [channel] [value]).")
    print("    dmxcommands                        - print the current DMX commands.")
    print("    help                               - display this text")
    print("    exit                               - close pydmx\n")
    print("Curses UI:")
    print("    Up        - increment the value of the current channel.")
    print("    Down      - decrement the value of the current channel.")
    print("    Left      - change to the previous channel.")
    print("    Right     - change to the next channel.")
    print("    Page Up   - increment the value of the current channel by 10.")
    print("    Page Down - decrement the value of the current channel by 10.")
    print("    n         - change to the next discrete region for that channel.")
    print("    p         - change to the previous discrete region for that channel.")
    print("    t         - change the value of the channel to 255.")
    print("    b         - change the value of the channel to 0.")
    print("    h         - toggle hold mode. Any changes made in hold more are applied when hold mode is disabled.")
    print("    d         - equivalent of dbo command.")
    print("    r         - equivalent of reload command.")
    print("    q         - close the interface.\n")
    print("PyDMX requires that dmxd be running as root, and that k8062 be executable and in your $PATH.")
    print("PyDMX is developed and maintained by Barrucadu (Michael Walker).")

def dmxcmd(channel, value=None, name=None, holding=False):
    global activename
    global chandata
    global bindddata
    global dmxcommands
    
    if name == None:
        name = activename

    argvector = []
    if value == None:
        argvector = dmxcommands['get'].replace('[channel]', str(channel)).split()
    else:
        chandata[name][channel][0] = int(value)
        argvector = dmxcommands['set'].replace('[channel]', str(channel)).replace('[value]', str(value)).split()

        if name in binddata.keys():
            for binded in binddata[(name, channel)]:
                if not chandata[binded[0]][binded[1]][0] = int(value):
                    dmxcmd(binded[1], value, binded[0], holding)

    if not holding:
        process = subprocess.Popen(argvector, stdout=subprocess.PIPE)
        output  = process.communicate()

    if value == None:
        try:
            return int(output[0])
        except ValueError:
            print("Dmxd does not seem to be running.")
            sys.exit()

def loaddmx(name):
    global chandata

    loaded = False
    for chan in chandata[name].keys():
        if not chan == 'info':
            newval = dmxcmd(chan + chandata[name]['info']['startchan'])
            if not chandata[name][chan][0] == newval:
                chandata[name][chan][0] = newval
                loaded = True

    return loaded

def applyheldchanges():
    global activename
    global chandata

    for channel in chandata[activename].keys():
        if not channel == 'info':
            dmxcmd(channel, chandata[activename][0])

def dbo():
    global activename
    global chandata
    global dbodata

    if not dbodata == {}:
        for channel in dbodata.keys():
            dmxcmd(channel, dbodata[channel])
        dbodata = {}
    else:
        for channel in chandata[activename].keys():
            if not channel == 'info':
                dbodata.update({channel : chandata[activename][0]})
                dmxcmd(channel, 0)

def nameinit(newname, newmodel, newstartchan):
    global chandata
    global data

    datafile = datapath + "/pydmx/" + newmodel + ".py"
    
    try:
        data = imp.load_source(newmodel, datafile)
    except IOError:
        print("The datafile " + datapath + " does not exist.")

    chandata.update({newname : {'info' : {'model'     : newmodel,
                                          'startchan' : int(newstartchan)}}})
    for i in data.dmx.keys():
        for j in data.dmx[i].keys():
            key = data.dmx[i][j][1]
            var = [data.dmx[i][j][0], data.dmx[i][j][2]]
            
            if len(data.dmx[i][j]) > 3:
                var.append(data.dmx[i][j][3])
        
            if key in chandata[newname].keys():
                chandata[newname][key].append(var)
            else:
                chandata[newname].update({key : [0, var]})

    dontload = loaddmx(newname)

    if not dontload:
        for channel in range(0, len(data.defaults)):
            dmxcmd(channel, data.defaults[channel], newname)
             

def updateui(stdscr, active, holding):
    global chandata
    global activename
    global data

    channels = chandata[activename]

    stdscr.erase()

    numbars       = len(channels) - 1
    height, width = stdscr.getmaxyx()
    barsize       = int((width - 12) / numbars)
    barheight     = height - 15
    barwidth      = 2

    stdscr.move(1, 1)
    if holding:
        if dbo:
            stdscr.addstr("[Holding/DBO]", curses.color_pair(4) and curses.A_BLINK and curses.A_BOLD)
        else:
            stdscr.addstr("[Holding]", curses.color_pair(4) and curses.A_BLINK and curses.A_BOLD)            
    elif dbo:
        stdscr.addstr("[DBO]", curses.color_pair(4) and curses.A_BLINK and curses.A_BOLD)

    stdscr.move(height - 3, 1)
    stdscr.addstr("Name:   ", curses.color_pair(5) and curses.A_BOLD)
    stdscr.addstr(activename)
    
    stdscr.move(height - 2, 1)
    stdscr.addstr("Device: ", curses.color_pair(5) and curses.A_BOLD)
    stdscr.addstr(data.name)

    for i in range(0, numbars):
        channel = channels[i]
        value = channel[0]
        
        stdscr.move(5, i * barsize + 6)
        
        attr = curses.color_pair(0)
        if i == active:
            attr = curses.color_pair(4)
            
        stdscr.addstr(data.channels[i], attr)

        stdscr.move(6, i * barsize + 6)
        stdscr.addstr(str(value))

        stdscr.move(8, i * barsize + 6)
        stdscr.addch(curses.ACS_ULCORNER)
        
        for j in range(0, barwidth):
            stdscr.addch(curses.ACS_HLINE)
            
        stdscr.addch(curses.ACS_URCORNER)

        goesupto = 0
        if not value == 0:
            goesupto = int(barheight * value / 255)
        
        for j in range(1, barheight):
            stdscr.move(j + 8, i * barsize + 6)
            stdscr.addch(curses.ACS_VLINE)

            y = barheight - j
            
            for k in range(0, barwidth):
                attr = curses.color_pair(0)
                
                if y <= goesupto:
                    if y >= 2 * barheight / 3:
                        attr = curses.color_pair(1)
                    elif y >= barheight / 3:
                        attr = curses.color_pair(2)
                    else:
                        attr = curses.color_pair(3)
                    
                stdscr.addch(" ", attr)
                
            stdscr.addch(curses.ACS_VLINE)

        stdscr.move(8 + barheight, i * barsize + 6)
        stdscr.addch(curses.ACS_LLCORNER)
        
        for j in range(0, barwidth):
            stdscr.addch(curses.ACS_HLINE)
            
        stdscr.addch(curses.ACS_LRCORNER)
        
        stdscr.move(10 + barheight, i * barsize + 6)
        stdscr.addstr(str(i + chandata[activename]['info']['startchan']))

        if active == i:
            stdscr.move(height - 1, 1)
            stdscr.addstr("State:  ", curses.color_pair(5) and curses.A_BOLD)

            highest = None
            for chan in channel:
                if type(chan) is list:
                    if chan[0] <= value and (highest == None or chan[0] > highest[0]):
                        highest = chan

            stdscr.addstr(highest[1])

def cursesui(stdscr):
    global chandata
    global activename
    
    curses.curs_set(0)

    activechan = 0
    holding    = False
    
    curses.init_pair(1, curses.COLOR_RED,   curses.COLOR_RED)
    curses.init_pair(2, curses.COLOR_BLUE,  curses.COLOR_BLUE)
    curses.init_pair(3, curses.COLOR_GREEN, curses.COLOR_GREEN)
    curses.init_pair(4, curses.COLOR_RED,   curses.COLOR_BLACK)
    curses.init_pair(5, curses.COLOR_CYAN,  curses.COLOR_BLACK)

    while True:
        updateui(stdscr, activechan, holding)
        
        ch     = stdscr.getch()
        newval = -1
        
        if ch == ord('q'):
            break
        
        elif ch == ord('r'):
            loaddmx(activename)

        elif ch == ord('h'):
            if holding:
                holding = False
                applyheldchanges()
            else:
                holding = True

        elif ch == ord('d'):
            dbo()

        elif ch == curses.KEY_LEFT:
            if not activechan == 0:
                activechan -= 1
                
        elif ch == curses.KEY_RIGHT:
            if not activechan == len(chandata[activename]) - 1:
                activechan += 1
                
        elif ch in [curses.KEY_UP, curses.KEY_PPAGE, ord('n')]:
            for cmd in chandata[activename][activechan]:
                if type(cmd) is list:
                    newdata = chandata[activename][activechan][0] + 1
                    if ch == curses.KEY_PPAGE:
                        newdata += 9

                    if 0 <= newdata <= 255 and not ch == ord('n'):
                        newval = newdata
                    elif cmd[0] > chandata[activename][activechan][0]:
                        if cmd[0] < newval or newval == -1:
                            newval = cmd[0]
                            
        elif ch in [curses.KEY_DOWN, curses.KEY_NPAGE, ord('p')]:
            for cmd in chandata[activename][activechan]:
                if type(cmd) is list:
                    newdata = chandata[activename][activechan][0] - 1
                    if ch == curses.KEY_NPAGE:
                        newdata -= 9

                    if 0 <= newdata <= 255 and not ch == ord('p'):
                        newval = newdata
                    elif cmd[0] < chandata[activename][activechan][0]:
                        if cmd[0] > newval or newval == -1:
                            newval = cmd[0]
                            
        elif ch == ord('t'):
            newval = 255
            
        elif ch == ord('b'):
            newval = 0
            
        if not newval == -1:
            dmxcmd(activechan, newval, None ,holding)
    
    curses.curs_set(1)

def listcmds(arg):
    global data
    
    print("Commands for " + data.name + ":")
    for i in data.dmx.keys():
        if arg == "" or arg == i:
            commands = []
            longest  = 0
            
            for j in data.dmx[i].keys():
                cmd = "'" + j + " [" + str(data.dmx[i][j][0]) + "+]'"
                    
                commands.append([cmd, data.dmx[i][j][2]])
                
                if len(cmd) > longest:
                    longest = len(cmd)

            print(i)
            for cmd in commands:
                spacing = longest - len(cmd[0])
                print("    " + cmd[0], cmd[1].rjust(len(cmd[1]) + spacing))
            print()
            
def parsecmd(command, args):
    global data
    global chandata
    global activename
    global binddata
    global dmxcommands
    
    funbreak = False

    if command == "list":
        listcmds(arg)
    elif command == "curses":
        curses.wrapper(cursesui)
    elif command == "names":
        for name in chandata.keys():
            if name == activename:
                print(name, "[active]")
            else:
                print(name)
                
            print("    Model:", chandata[name]['info']['model'])
            print("    Start:", chandata[name]['info']['startchan'])
            
    elif command == "new":
        if len(args) < 3 or args[0] == "" or args[1] == "" or args[2] == "":
            print("Usage: new [name] [model] [startchannel]")
        else:
            nameinit(args[0], args[1], args[2])

    elif command == "change":
        if len(args) < 1 or args[0] == "" or not args[0] in chandata.keys():
            print("Usage: change [name]")
        else:
            activename = args[0]

    elif command == "reload":
        loaddmx(activename)
        
    elif command == "rename":
        if len(args) < 2 or not args[0] in chandata.keys() or not args[1] in chandata.keys() or args[1] == "":
            print("Usage: rename [old] [new]")
        else:
            chandata.update({args[1] : chandata[args[0]]})
            chandata.pop(args[0])

    elif command == "dbo":
        dbo()

    elif command == "bind":
        if (args[0], args[1]) in binddata.keys():
            binddata[(args[0], args[1])].append((args[2], args[3]))
        else:
            binddata.update({(args[0], args[1]) : [(args[2], args[3])]})
        
        if (args[2], args[3]) in binddata.keys():
            binddata[(args[2], args[3])].append((args[0], args[1]))
        else:
            binddata.update({(args[2], args[3]) : [(args[0], args[1])]})

    elif command == "unbind":
        if (args[0], args[1]) in binddata.keys():
            binddata[(args[0], args[1])].remove((args[2], args[3]))
        
        if (args[2], args[3]) in binddata.keys():
            binddata[(args[2], args[3])].remove((args[0], args[1]))

    elif command == "dmxsetcmd":
        dmxcommands['set'] = ' '.join(args)

    elif command == "dmxgetcmd":
        dmxcommands['get'] = ' '.join(args)        

    elif command == "dmxcommands":
        print("Get:", dmxcommands['get'])
        print("Set:", dmxcommands['set'])

    elif command == "help":
        printhelp()
        
    else:
        try:
            cmd = data.dmx[command][args[0]]
        except KeyError:
            print("Command not found")
            funbreak = True
            
        if not funbreak:
            value = 0
            try:
                value = int(args[1])
            except ValueError:
                value = cmd[0]
                
            dmxcmd(cmd[1], value)

def parsepromptline(line):
    bar      = line.split()
    command  = ""
    args     = []
    funbreak = False

    try:
        command = bar[0]
        args    = bar[1:]
    except IndexError:
        funbreak = True

    return command, args, funbreak


def enterprompt():
    funbreak = False

    foo = input("> ")
    
    if foo == "exit": 
        return False
    else:
        command, args, funbreak = parsepromptline(foo)
        if not funbreak:
            parsecmd(command, args)
    return True

# ----- Main ----- #
datapath = os.getenv("XDG_DATA_HOME")
if datapath == "":
    datapath = os.getenv("HOME") + "/.local/share"

if "help" in sys.argv or "-h" in sys.argv or "--help" in sys.argv:
    printhelp()
    sys.exit(0)
else:
    if len(sys.argv) > 2:
        model = sys.argv[1]
        startchan = int(sys.argv[2])
        nameinit('start', model, startchan)
        activename = 'start'
        
looping = True

while looping:
    looping = enterprompt()

print("Exiting...")
sys.exit(0)
