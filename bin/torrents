#!/usr/bin/env python3

"""torrents. Get information about a running rtorrent instance.

Usage:
  torrents [(start | stop | hash)] [--url=<url>] [-i] [<filter>] [--files]

Options:
  start        Start the matching torrents.
  stop         Stop the matching torrents.
  hash         Hash-check the matching torrents.
  --url=<url>  XMLRPC URL. [default: http://localhost/]
  -i           Be case insensitive when filtering.
  <filter>     Regex to filter torrents by.
  --files      List the files of each matching torrent.
"""

from docopt import docopt
from xmlrpc.client import ServerProxy
import re
from functools import total_ordering


@total_ordering
class Torrent:
    """Class to represent a torrent.
    """

    def __init__(self, proxy, infohash):
        """Create a new torrent object.

        :param proxy: The XMLRPC server proxy to use.
        :param infohash: The infohash of the torrent.
        """

        self.pad = ' '

        self.proxy = proxy
        self.infohash = infohash
        self.name = proxy.d.get_name(infohash)

        self.base_dir = proxy.get_directory()
        self.dir = proxy.d.get_directory(infohash)[len(self.base_dir) + 1:]
        if self.dir:
            self.dir += '/'

        self.numfiles = proxy.d.get_size_files(infohash)
        self.files = [self.dir + proxy.f.get_path('{}:f{}'.format(infohash, i))
                      for i in range(0, self.numfiles)]
        self.files.sort()

    def complete(self):
        """Check if complete.
        """

        return self.proxy.d.get_complete(self.infohash)

    def hashing(self):
        """Check if hash checking.
        """

        return self.proxy.d.is_hash_checking(self.infohash)

    def queued(self):
        """Check if queued for hash checking.
        """

        return self.proxy.d.get_hashing(self.infohash)

    def active(self):
        """Check if active.
        """

        return self.proxy.d.is_active(self.infohash)

    def start(self):
        """Try to start.
        """

        self.proxy.d.try_start(self.infohash)

    def stop(self):
        """Try to stop.
        """

        self.proxy.d.try_stop(self.infohash)

    def hash(self):
        """Start a hash-check.
        """

        self.proxy.d.check_hash(self.infohash)

    def __eq__(self, other):
        return self == other

    def __lt__(self, other):
        return self.name < other.name

    def __str__(self):
        return "{}{}{} {} {} [files: {}]".format(
            self.name,
            self.pad,
            '[A]' if self.active() else ' - ',
            '[C]' if self.complete() else ' - ',
            '[H]' if self.hashing() else '[Q]' if self.queued() else ' - ',
            self.numfiles)


def get_matching_torrents(proxy, pattern):
    """Get the list of torrent ID/name tuples which match the filter.

    :param proxy:   XMLRPC server proxy.
    :param pattern: Regex to match against.
    """

    torrents = list(filter(lambda t: pattern.search(t.name),
                           [Torrent(proxy, infohash)
                            for infohash in proxy.download_list()]))

    maxlen = len(max(torrents, key=lambda t: len(t.name)).name)
    for torrent in torrents:
        torrent.pad = ' ' * (maxlen - len(torrent.name) + 4)

    return sorted(torrents)

if __name__ == "__main__":
    arguments = docopt(__doc__)
    proxy = ServerProxy(arguments['--url'])
    pattern = re.compile(arguments['<filter>'] or "",
                         flags=re.I if arguments['-i'] else 0)

    try:
        for torrent in get_matching_torrents(proxy, pattern):
            if arguments['start']:
                torrent.start()
            elif arguments['stop']:
                torrent.stop()
            elif arguments['hash']:
                torrent.hash()

            if arguments['--files']:
                for file in torrent.files:
                    print(file)
            else:
                print(torrent)
    except:
        print("XMLRPC error. Check URL.")
