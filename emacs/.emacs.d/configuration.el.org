* Emacs Configuration

My emacs configuration is a literate Emacs Lisp program, using
=org-mode= [[http://orgmode.org/worg/org-contrib/babel/intro.html][Babel]]. I got the idea from [[https://www.youtube.com/watch?v=SzA2YODtgK4][this talk by Harry Schwartz]], see
about 20 minutes in.

** Personal information

#+BEGIN_SRC emacs-lisp
  (setq user-full-name    "Michael Walker"
        user-mail-address "mike@barrucadu.co.uk")
#+END_SRC

** Package management

I use [[https://github.com/jwiegley/use-package][=use-package=]] to manage most of my configuration, which includes
fetching packages. It's incredibly convenient, and results in very
readable config. There's a great blog post by Sebastian Wiesner [[http://www.lunaryorn.com/2015/01/06/my-emacs-configuration-with-use-package.html][on his
use of it]].

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))

  (package-initialize)

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)
#+END_SRC

** User interface
*** Get rid of the tool bar, menu bar, and scroll bar.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (when window-system
    (scroll-bar-mode -1))
#+END_SRC

*** No blinking and beeping

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'blink-cursor-mode)
    (blink-cursor-mode -1))
  (setq ring-bell-function 'ignore)
#+END_SRC

*** No splash screen on startup

#+BEGIN_SRC emacs-lisp
  (setq inhibit-splash-screen t)
#+END_SRC

*** Zenburn colour theme

This is the first use of =use-package= in the configuration. This
snippet requires the =color-theme= and =zenburn-theme= packages to be
installed (and will fetch them if not, due to the =(setq
use-package-always-ensure t)= in the =use-package= configuration), and
loads the zenburn theme at start-up.

#+BEGIN_SRC emacs-lisp
  (use-package color-theme)
  (use-package zenburn-theme
    :init (load-theme 'zenburn 'no-confirm))
#+END_SRC

*** Highlights
**** Cursor on window scroll

The =:diminish= here uses [[https://github.com/myrjola/diminish.el][=diminish=]] to remove [[https://github.com/Malabarba/beacon][=beacon-mode=]] from the
mode-line, as I'm enabling it globally.

#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :init (beacon-mode 1)
    :diminish beacon-mode)
#+END_SRC

**** The current line

Changes the background of the current line when in a windowing system
(alas, would be nice if it also worked in the terminal).

#+BEGIN_SRC emacs-lisp
  (when window-system
    (global-hl-line-mode 1))
#+END_SRC

**** Matching parentheses

By default, =show-paren-mode= has a slight delay. I don't like that,
so I set =show-paren-delay= to turn it off.

#+BEGIN_SRC emacs-lisp
  (setq show-paren-delay 0)
  (show-paren-mode 1)
#+END_SRC

The [[https://github.com/Fanael/rainbow-delimiters][=rainbow-delimiters=]] package uses different colours for nested
parentheses, making them easier to visually track.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :init (progn (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
                 (add-hook 'conf-mode-hook 'rainbow-delimiters-mode)))
#+END_SRC

*** The mode line

Basically copied from spacemacs. I'm using [[https://github.com/milkypostman/powerline][=powerline=]] for the fancy
modeline, and am using [[https://github.com/TheBB/spaceline][=spaceline=]] to get a spacemacs-like mode
line. The =:ensure spaceline= fetches and installs the =spaceline=
package if it's not already present. The =:after spaceline-config=
ensures that =powerline= is only started after =spaceline-config= has
successfully run.

#+BEGIN_SRC emacs-lisp
  (use-package spaceline-config
    :ensure spaceline
    :config (spaceline-compile
      'barrucadu
      '(((buffer-modified buffer-size input-method) :face highlight-face)
        anzu
        '(buffer-id remote-host buffer-encoding-abbrev)
        ((point-position line-column buffer-position selection-info)
         :separator " | ")
        major-mode
        process
        (flycheck-error flycheck-warning flycheck-info)
        ((minor-modes :separator spaceline-minor-modes-separator) :when active))
      '((version-control :when active)))
      (setq-default mode-line-format '("%e" (:eval (spaceline-ml-barrucadu)))))

  (use-package powerline
    :after spaceline-config
    :config (setq powerline-height (truncate (* 1.0 (frame-char-height)))
                  powerline-default-separator 'utf-8))
#+END_SRC

** Keybindings

I use a simple prefix scheme for all my custom keybindings, pretty
much everything has the form =C-c <key> <binding>=, where =<key>= is
some operation-specific key. I use [[https://github.com/justbur/emacs-which-key][=which-key=]] to provide hints based
on this scheme.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :init (which-key-mode)
    :config
    (setq which-key-idle-delay 0.3
          which-key-sort-order 'which-key-prefix-then-key-order)

    (which-key-declare-prefixes
      ;; Global prefixes and minor modes
      "C-c @"   "outline"
      "C-c !"   "flycheck"
      ;; Prefixes for my personal bindings
      "C-c b"   "buffers"
      "C-c c"   "comments"
      "C-c f"   "files"
      "C-c g"   "git"
      "C-c l"   "language/spelling"
      "C-c m"   "major-mode"
      "C-c o"   "cursors"
      "C-c p"   "projectile"
      "C-c s"   "search"
      "C-c t"   "toggle"
      "C-c x"   "text")

    ;; Prefixes for major modes
    (which-key-declare-prefixes-for-mode 'markdown-mode
      "C-c TAB" "markdown/images"
      "C-c C-a" "markdown/links"
      "C-c C-c" "markdown/process"
      "C-c C-s" "markdown/style"
      "C-c C-t" "markdown/header"
      "C-c C-x" "markdown/structure")

    (which-key-declare-prefixes-for-mode 'haskell-mode
      "C-c m"   "haskell/personal"
      "C-c m i" "haskell/imports")

    (which-key-declare-prefixes-for-mode 'go-mode
      "C-c m"   "go/personal")
    :diminish which-key-mode)
#+END_SRC

** Flycheck and Flyspell

The [[http://www.flycheck.org/][=flycheck=]] package is a fantastically useful piece of work, it
performs continuous mode-specific correctness-checking (eg: compiler
errors for programming). The [[https://www.emacswiki.org/emacs/FlySpell][=flyspell=]] package is similar for
text. Both are great. You're doing it wrong if you're not using both.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :init (global-flycheck-mode))
#+END_SRC

Here we also see an example of binding keys with =use-package=. The
=C-c t= prefix is for text commands, and so is used here for flyspell.

#+BEGIN_SRC emacs-lisp
  (use-package flyspell
    :bind (("C-c t s" . flyspell-mode)
           ("C-c l b" . flyspell-buffer))
    :init (progn (add-hook 'text-mode-hook  'flyspell-mode)
                 (add-hook 'prog-mode-hook  'flyspell-prog-mode)
                 (add-hook 'org-mode-hook   'flyspell-mode)
                 (add-hook 'LaTeX-mode-hook 'flyspell-mode))
    :config (progn (setq flyspell-use-meta-tab nil
                         flyspell-issue-welcome-flag nil
                         flyspell-issue-message-flag nil)
                   (define-key flyspell-mode-map "\M-\t" nil)
                   (define-key flyspell-mouse-map [down-mouse-2] nil)
                   (define-key flyspell-mouse-map [mouse-2] nil))
    :diminish flyspell-mode)
#+END_SRC

I use =aspell= for =flyspell-mode=:

#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :defer t
    :config (setq ispell-program-name (executable-find "aspell")
                  ispell-dictionary "en_GB"
                  ispell-silently-savep t
                  ispell-choices-win-default-height 5))
#+END_SRC

** Accounting

I use [[http://plaintextaccounting.org/][plaintext accounting]], and in particular [[http://hledger.org/][hledger]], to manage my
finances. It's really nice and I highly recommend it. I have a page
about it [[https://wiki.barrucadu.co.uk/finance.shelf.html][on my wiki]].

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-ledger)
  (use-package ledger-mode
    :mode "\\.ledger\\'\\|\\.journal\\'"
    :config
    (setq ledger-binary-path (executable-find "hledger")
          ledger-mode-should-check-version nil
          ledger-init-file-name " "
          ledger-post-amount-alignment-column 0
          ledger-highlight-xact-under-point nil)
    (add-hook 'ledger-mode-hook (lambda () (setq tab-width 1)))
    (add-hook 'ledger-mode-hook 'orgstruct-mode))
#+END_SRC

** Programming

My programming set-up is quite simple compared to all the
functionality that emacs can offer: flycheck and syntax highlighting
provide basically everything I want.

Emacs' default "electric" indenting can be a bit overzealous
(particularly for Haskell, it seems), so turn that off:

#+BEGIN_SRC emacs-lisp
  (electric-indent-mode 0)
#+END_SRC

I also like to be able to comment things easily.  The =bind-key=
package being used here is part of =use-package=. Because I can never
remember, "dwim" is an acronym for "do what I mean".

#+BEGIN_SRC emacs-lisp
  (require 'bind-key)
  (bind-key "C-c c d" 'comment-dwim)
  (bind-key "C-c c l" 'comment-line)
  (bind-key "C-c c r" 'comment-region)
#+END_SRC

Ok, that's it for preliminaries.

*** Forth

#+BEGIN_SRC emacs-lisp
  (use-package forth-mode
    :mode "\\.fs\\'")
#+END_SRC

*** Haskell

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :mode "\\.hs\\'"
    :bind (:map haskell-mode-map
                ("M-."       . haskell-mode-jump-to-def-or-tag)
                ("C-c m i j" . haskell-navigate-imports)
                ("C-c m i s" . haskell-sort-imports)
                ("C-c m i a" . haskell-align-imports)))

  (use-package haskell-compile
    :ensure haskell-mode
    :bind (:map haskell-mode-map
                ("C-c m c" . haskell-compile)
                ("<f5>"    . haskell-compile))
    :config (setq haskell-compile-cabal-build-command "stack build"))

  (use-package haskell-cabal-mode
    :mode "\\.cabal\\'"
    :ensure haskell-mode)
#+END_SRC

*** JSON

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode "\\.json\\'"
    :config (add-hook 'json-mode-hook (lambda () (setq-local js-indent-level 4))))

  (use-package json-reformat
    :bind (("C-c x j" . json-reformat-region)))
#+END_SRC

*** Python

#+BEGIN_SRC emacs-lisp
  (use-package python
    :mode ("``.py``'" . python-mode))
#+END_SRC

*** Go

This runs =gofmt= on save, which is really convenient.

#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :mode "\\.go\\'"
    :commands (godoc gofmt gofmt-before-save)
    :bind (:map go-mode-map
                ("C-c m f" . gofmt)
                ("C-c m i" . go-goto-imports)
                ("C-c m r" . go-remove-unused-imports))
    :init (progn (defun barrucadu/maybe-gofmt-before-save ()
                   (when (eq major-mode 'go-mode)
                     (gofmt-before-save)))
                 (add-hook 'before-save-hook 'barrucadu/maybe-gofmt-before-save)))
#+END_SRC

*** Lua

#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :mode "\\.lua\\'")
#+END_SRC

*** Nix

#+BEGIN_SRC emacs-lisp
  (use-package nix-mode
    :mode "\\.nix\\'")
#+END_SRC

*** Rust

Like with Go, this formats code on save.

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :mode "\\.rs\\'"
    :config  (setq rust-format-on-save t))
  (use-package flycheck-rust
    :init (add-hook 'flycheck-mode-hook 'flycheck-rust-setup))
#+END_SRC

*** Shell

#+BEGIN_SRC emacs-lisp
  (use-package sh-script
    :mode ("\\.zsh\\'" . sh-mode)
    :config (setq sh-indentation 2
                  sh-basic-offset 2))
#+END_SRC

*** TOML

#+BEGIN_SRC emacs-lisp
  (use-package toml-mode
    :mode ("\\.toml``'" . toml-mode))
#+END_SRC

*** YAML

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.yaml\\'"
    :config (add-hook 'yaml-mode-hook (lambda () (run-hooks 'prog-mode-hook))))
#+END_SRC

** Writing

I have a couple of modes available for distraction-free writing:

#+BEGIN_SRC emacs-lisp
  (use-package writeroom-mode
    :bind (("C-c t r" . writeroom-mode)))

  (use-package focus
    :bind (("C-c t f" . focus-mode)))
#+END_SRC

The [[https://github.com/joostkremers/writeroom-mode][=writeroom-mode=]] package hides most of the interface and centres
the text, similar to the writeroom text editor; and the [[https://github.com/larstvei/Focus][=focus=]]
package dims surrounding paragraphs. They make a good combination.

*** LaTeX

Automatically parse TeX files after opening, insert braces
automatically for math mode sub/superscripts, and attempt to "do what
I mean" in figuring out what the main tex file is.

#+BEGIN_SRC emacs-lisp
  (setq TeX-parse-self t
        TeX-electric-sub-and-superscript t
        TeX-master 'dwim)
#+END_SRC

Some help for managing bibtex databases: I like my formatting
consistent.

#+BEGIN_SRC emacs-lisp
  (setq bibtex-entry-format `(opts-or-alts numerical-fields page-dashes
                              last-comma delimiters unify-case sort-fields)
        bibtex-entry-delimiters 'braces
        bibtex-field-delimiters 'double-quotes
        bibtex-comma-after-last-field nil)

  (defvar barrucadu/bibtex-fields-ignore-list
    '("abstract" "acmid" "address" "annotation" "articleno" "doi" "eprint"
      "file" "isbn" "issn" "issue_date" "keywords" "language" "location"
      "month" "numpages" "url"))

  (defun barrucadu/bibtex-clean-entry-drop-fields ()
    (save-excursion
      (let (bounds)
        (when (looking-at bibtex-entry-maybe-empty-head)
          (goto-char (match-end 0))
          (while (setq bounds (bibtex-parse-field))
            (goto-char (bibtex-start-of-field bounds))
            (if (member (bibtex-name-in-field bounds)
                        barrucadu/bibtex-fields-ignore-list)
                (kill-region (caar bounds) (nth 3 bounds))
              (goto-char (bibtex-end-of-field bounds))))))))

  (defun barrucadu/bibtex-clean-entry-newline ()
    (save-excursion
      (progn (bibtex-end-of-entry) (left-char) (newline))))

  (add-hook 'bibtex-clean-entry-hook 'barrucadu/bibtex-clean-entry-newline)
  (add-hook 'bibtex-clean-entry-hook 'barrucadu/bibtex-clean-entry-drop-fields)
#+END_SRC

*** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode "\\.md\\'\\|\\.markdown\\'")
#+END_SRC

*** Org

I use =org-mode= as my default major-mode, not just for org files.

#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'org-mode)
  (add-hook 'org-mode-hook 'org-indent-mode)
  (add-hook 'org-mode-hook 'visual-line-mode)
  (setq org-src-tab-acts-natively t
        org-src-fontify-natively t
        org-enforce-todo-dependencies t
        org-enforce-todo-checkbox-dependencies t
        org-agenda-dim-blocked-tasks t
        org-log-done 'time
        org-agenda-files '("~/s/org"))
  (require 'org-habit)
  (add-to-list 'org-modules 'org-habit)
  (bind-key "C-c a" 'org-agenda)
#+END_SRC

** Version control

Highlight diffs in the buffer:

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :defer t
    :init
    (global-diff-hl-mode)
    (add-hook 'dired-mode-hook 'diff-hl-dired-mode)
    (unless (display-graphic-p) (diff-hl-margin-mode))
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
#+END_SRC

The [[https://magit.vc/][=magit=]] package is the best thing since sliced bread:

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind (("C-c g c" . magit-clone)
           ("C-c g s" . magit-status)
           ("C-c g b" . magit-blame)
           ("C-c g l" . magit-log-buffer-line)
           ("C-c g p" . magit-pull))
    :config (setq magit-save-repository-buffers 'dontask
                  magit-refs-show-commit-count 'all
                  magit-revision-show-gravatars nil))
#+END_SRC

The [[https://github.com/pidu/git-timemachine][=git-timemachine=]] package is quite handy for stepping through old
versions of things:

#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :bind (("C-c g t" . git-timemachine)))
#+END_SRC

** Miscellaneous
*** Change some silly defaults

Don't make backup files:

#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC

Kill whole lines:

#+BEGIN_SRC emacs-lisp
  (setq kill-whole-line t)
#+END_SRC

I find "C-x u" much more awkward to type than "C-x C-u":

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x C-u" 'undo)
#+END_SRC

I am incredibly lazy and don't like to type "yes" when "y" will suffice:

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

"Tabs are the devil's whitespace" - Harry Schwartz:

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil
                tab-width 8)
#+END_SRC

End files with a trailing newline:

#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
#+END_SRC

*** Buffer management and navigation

Use the "forward" style of creating unique buffer names, which
includes part of the directory in the buffer name:

#+BEGIN_SRC emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
#+END_SRC

Add a binding to switch to the previous buffer:

#+BEGIN_SRC emacs-lisp
  (defun barrucadu/switch-to-previous-buffer ()
    (interactive)
    (switch-to-buffer (other-buffer)))
  (bind-key "C-c b x" 'barrucadu/switch-to-previous-buffer)
#+END_SRC

Bind a key to jump to a line:

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x g" 'goto-line)
#+END_SRC

*** Whitespace

Use [[https://github.com/purcell/whitespace-cleanup-mode][=whitespace-cleanup-mode=]] to sort out trailing whitespace, and
make whitespace optionally visible (trailing whitespace is always
visible):

#+BEGIN_SRC emacs-lisp
  ;;;; Whitespace management
  (use-package whitespace-cleanup-mode
    :bind (("C-c t c" . whitespace-cleanup-mode)
           ("C-c x w" . whitespace-cleanup))
    :init (dolist (hook '(prog-mode-hook text-mode-hook conf-mode-hook))
            (add-hook hook 'whitespace-cleanup-mode))
    :diminish (whitespace-cleanup-mode . " [W]"))

  (use-package whitespace
    :bind (("C-c t w" . whitespace-mode))
    :config (setq whitespace-line-column nil)
    :diminish whitespace-mode)

  (bind-key "C-c x d" 'delete-horizontal-space)
  (setq-default show-trailing-whitespace t)
#+END_SRC

*** Visual regexp search and replace

#+BEGIN_SRC emacs-lisp
  (use-package visual-regexp
    :bind (("C-c s r" . vr/query-replace)
           ("C-c s R" . vr/replace)))
#+END_SRC

*** Helm

The [[https://emacs-helm.github.io/helm/][=helm=]] package provides incremental completion of lots of things,
so I enable it globally. For example, this makes =M-x= much nicer.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :bind ("M-x" . helm-M-x)
    :init (helm-mode 1)
    :diminish helm-mode)
#+END_SRC

Manage buffers with =helm=:

#+BEGIN_SRC emacs-lisp
  (use-package helm-buffers
    :ensure helm
    :defer t
    :bind (([remap switch-to-buffer] . helm-mini))
    :config (setq helm-buffers-fuzzy-matching t))
#+END_SRC

Manage files with =helm=:

#+BEGIN_SRC emacs-lisp
  (use-package helm-files
    :ensure helm
    :defer t
    :bind (([remap find-file] . helm-find-files)
           ("C-c f f" . helm-for-files)
           ("C-c f r" . helm-recentf))
    :config (setq helm-recentf-fuzzy-match t
                  helm-ff-file-name-history-use-recentf t
                  helm-ff-search-library-in-sexp t))
#+END_SRC

*** Projectile

The [[https://github.com/bbatsov/projectile][=projectile=]] package is a project integration library, providing
nice functionality at the level of all files in a git repository
(amongst others).

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :init (projectile-global-mode)
    :config (setq projectile-completion-system 'helm))
#+END_SRC

Use =helm= for autocompletion:

#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :after projectile
    :bind ("C-c f p" . helm-projectile)
    :config
    (helm-projectile-on)
    (setq projectile-switch-project-action 'helm-projectile))
#+END_SRC

*** The Insidious Big Brother Database

The [[http://savannah.nongnu.org/projects/bbdb/][=bbdb=]] package is an address book for emacs.

#+BEGIN_SRC emacs-lisp
  (use-package bbdb
    :config (setq bbdb-file "~/s/contacts.bbdb")
            (bbdb-initialize))
#+END_SRC
